#Day 07
##Test
- 예외상황에 대한 일관성 있는 기준 필요
	- 어떤 메서드는 null을 리턴하고, 어떤 메서드는 exception을 던지고 하면 안됨
- 네거티브 테스트부터 만들 것
	- 예외적인 상황은 빼먹고 넘어가기 쉽다
- 테스트 케이스는 사용자 입장에서 작성해야
	- 내부 로직 등을 모른다는 생각으로 작성해야 구현 알고리즘이 바뀌더라도 검증 가능
- 구체적인 알고리즘을 테스트해야 하는가?
	- 변화에 취약한 테스트 코드 -> 구현 로직이 바뀔 때마다 테스트 케이스 새로 작성

##템플릿/콜백 패턴
- 특정 템플릿의 콜백 역시 템플릿/콜백 패턴으로 구현할 수 있다
- 템플릿/콜백 패턴을 구현하는 것이 목적이 아니라 좋은 코드(SOC, 높은 결합도와 낮은 응집도, 개방폐쇄 원칙 등을 충족시키는 객체지향적 코드)를 작성하는 것이 목적
- 템플릿/콜백 패턴은 중첩으로 계속 발생할 수 있다.
- 템플릿과 콜백의 타입이 다양하게 바뀔 수 있다면 제네릭스를 이용
- 콜백 오브젝트는 (전략 메서드가 하나이기 때문에) lambda 적용을 고려
- 스피링에서 제공하는 다양한 템플릿/콜백을 활용

##예외
- DO NOT!!
	- catch를 하고 아무 것도 하지 않는 코드
		- 콘솔에 출력만 하는 코드도 마찬가지
		- 조치를 취할 방법이 없다면 잡지 말아야
	- throws Exception 메서드
		- 사용자가 Exception을 어떻게 처리해야 할 지 알 수 없다
			- 어떤 Exception이 발생할 지 모르므로
- 예외 처리 핵심 원칙
	- 적절하게 복구되든지
	- 작업을 중단시키고 운영자 또는 개발자에게 분명하게 통보돼야

###예외의 종류
- Error
	- java.lang.Error의 서브클래스
	- 시스템 레벨
	- 잡지 말 것
		- 할 것이 없음
- 체크 예외
	- java.lang.Exception 서브클래스 중 RuntimeException을 상속하지 않은 클래스
	- 반드시 예외 처리 코드 작성해야
- 언체크/런타임 예외
	- java.lang.RuntimeException의 서브클래스
	- 명시적 예외 처리 강제 하지 않음
		- 예외 처리 가능
	- 코드에서 예외가 발생하지 않도록 작성 가능
	- 혹은 예외 발생 시 **특별히 처리할 것**이 없는 경우
	- 자동으로 자신의 호출자에게 exception throw
		- 하이러퀴 상의 모든 메서드에 throws를 붙인 것과 마찬가지
		- 당연히 throw 이후의 로직은 실행되지 않는다
    ```java
	private void runThrow() {
		throwRuntimeException();
		System.out.println("in runThrow");    // 실행되지 않음
	}
	
	private void throwRuntimesException() {
		throw new RuntimeException();
	}
	```
- Spring의 Exception은 모두 언체크/런타임 예외
###예외처리 방법
- 예외 복구
- 예외 회
- 예외 전환
	- 사용자가 예외를 보다 적합하게 처리할 수 있도록 정보를 준다
	- 중첩 예외
		- 원래 발생한 예외를 담아 예외 전환
		- `getCause()`메소드 통해 처음 발생한 예외 참조 가능
		- 체크 예외를 언체크 예외로 바꾸는 경우에도 사용
```java
catch(SQLException e) {
	throw DuplicateUserIdException(e);
```
```java
catch(SQLException e) {
	throw DuplicateUserIdException().initCause(e);
```
###애플리케이션 예외
애플리케이션 자체 로직에 의해 의도적으로 발생시키고, 반드시 catch 해서 조치를 취하도록 요구하는 예외(애플리케이션 로직을 담기 위한 예외)

특별한 값을리턴하고 이를 검사하는 방법으로 대체 가능

대개 체크 예외로 만듦
###예외의 추상화
interface의 메서드가 특정 exception을 throws 해야 한다면,

implement 메서드들이 모두 같은 exception을 던져야 한다. implement 메서드들이 상이한 예외를 throws 하는 경우 interface를 사용할 수 없는 것.

이는 예외에 의한 의존성 강화로 볼 수 있을 것.

모든 예외를 런타임 예외로 포장하거나, 의미 있는 예외로 전환(**예외의 추상화**)해야 함.

그러나 어플리케이션 단에서 예외를 처리해야 하는 경우 구현 로직의 독립성을 갖는 데는 한계가 있다
>interface 메서드의 클라이언트에서 예외를 처리해야 한다면 구체화된 예외 정보가 필요할 수 있다. 그리고 구체화된 예외가 implement 메서드에 따라 상이하다면, 클라이언트는 interface가 아닌 implementation단과 의존성을 갖게 된다

>**결국 구현 로직의 변화에 크라이언트 코드가 영향을 받게 된다**
