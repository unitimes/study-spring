#어플리케이션 아키텍처
####아키텍처?
시스템의 구성 요소들이 어떤 **책임**을 갖고, 어떤 **관계**를 맺고 **동작**하는 지를 규정하는 것
##계층과 정보 처리
결국 아키텍트는 하나의 거대한 시스템(애플리케이션)을 구성 요소들로 **나누고** 구성 요소들간의 **관계를 설정**하는 것    
따라서 계층구조와 정보를 다루는 방법이 스프링 애플리케이션 아키텍처에 핵심

###구성 요소 나누기와 계층
애플리케이션을 **기능을 중심**으로 나눔으로써 아키텍처는 계층구조를 갖게 됨
>####**왜 기능을 중심으로 나누어야 하는가?**
>업무를 중심으로 설계한 아키텍처를 따르는 애플리케이션의 오브젝트들은 재사용성이 낮다. 각 오브젝트가 **업무에 대한 종속성**을 가지고 설계 되었기 때문이다.    
>기능을 중심으로 설계한 아키텍처를 따르는 애플리케이션의 오브젝트들은 업무에 대한 종속성 없이 기능만을 가지고 있기 때문에 어떠한 업무에서도 **동일한 기능**이 필요한 경우 재사용 가능하다.

아키텍처 레벨에서의 SoC가 기능을 중심으로 이루워져야 제대로 된 객체지향 오브젝트의 설계가 가능

계층구조를 갖는 아키텍처를 **계층형 아키텍처**, **멀티 티어 아키텍처**라 하며, 웹 기반의 엔터프라이즈 애플리케이션이 일반적으로 세 개의 계층을 가져 **3계층 애플리케이션**이라 함

###관계의 설정과 정보
구성 요소를 일단 나누고 나면 각 구성 요소가 해야할 일은 정해지는 셈. 결국 관계 설정의 핵심은 **어떠한 형식**으로 정보를 주고 받는가에 있음

따라서 정보를 어떻게 보고 어떻게 다룰 것인가를 결정하는 것이 아키텍처에서 중요    
크게 단순히 **데이터**로 다루는 경우와 **오브젝트**로 다루는 경우로 나뉨

##3계층 아키텍처
###데이터 액세스 계층
DAO 계층이라 불리며, 추상화 수준에 따라 수직적 계층 구조(i.e. DAO 코드 > JdbcTemplate > JDBC > DataSource)를 가짐    
추상화 계층은 필요에 따라 얼마든지 추가할 수 있으나 하위 계층의 변화에 대응할 수 있도록 만들어야

###서비스 계층
서비스 계층 클래스는 이상적인 POJO로 작성    
서비스 계층은 DAO 계층을 호출하고 이를 활용

원칙적으로 서비스 계층 코드는 기반 서비스 계층의 구현에 종속되면 안 되며, 추상화된 기반 서비스 인터페이스, AOP 등을 통해서 관계를 맺어야
>**기반 서비스 계층**    
>트랜잭션, 보안, 메일, 스케줄링 등의 서비스

###프레젠테이션 계층
매우 다양한 기술과 프레임워크의 조합을 가질 수 있기 때문에 가장 복잡한 계층    
>액티브X, 닷넷, 플래시 등

그러나 HTTP 프로토콜을 사용하는 서블릿이 바탕    

클라이언트까지 범위를 확장할 수도 있다.
>i.e. 프레젠테이션 계층의 로직을 처리하는 코드를 브라우저가 다운로드 받아 처리

###계층형 아키텍처 설계 원칙
**높은 응집도와 낮은 결합도가 기본**

결합도를 낮추기 위해서는 계층간 정보를 전달할 때 **특정 계층에 종속되지 않는** 오브젝트 형태로 전달해야 하며, 예의의 경우도 어플리케이션에서 처리해야 하는 로직이 아니면 **런타임 예외**로, 어플리케이션에서 처리해야 하는 로직이면 **추상화**를 통해 특정 구현 방식에 종속되지 않게 해야함    

또한 계층 사이의 호출은 반드시 인터페이스를 통해야 함. 각 계층의 경계를 넘어서 들어오는 **요청을 명확히** 한다는 의미
>따라서 인터페이스의 설계는 매우 신중해야

##데이터 중심 아키텍처
정보를 단순히 값이나 값을 담기 위한 목적의 오브젝트 형태로 취급, 따라서 특정 쿼리나 특정 업무(**원하는 데이타**)에 따라 **다양한 형태**를 가짐    

화면을 중심으로 하는 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향    
**낮은 응집도와 높은 결합도**

객체지향 기술이나 언어를 사용하지 않던 시절의 엔터프라이즈 애플리케이션과 크게 다를 바 없는 아키텍처

핵심 비즈니스 로직을 어디에 두느냐에 따라 **DB에 무게**를 두는 구조와 **서비스 계층**의 코드에 무게를 두는 구조로 구분

###DB 중심의 로직 구현
프레젠테이션 계층이 원하는 데이터를 리턴하는 로직이 **DAO계층의 SQL이나 DB의 저장 프로시저**에 담겨져 있는 형태    
빈약한 서비스 계층을 갖게 됨    

모든 계층의 코드가 업무에 종속적이며 다른 업무에 배타적이기 때문에 **변화에 취약**하고 **재사용성이 낮음**

애플리케이션은 DB에 대한 인터페이스 역할

####장점
- 개발하기 쉽다(직관적)
- 개발자간 업무 독립성이 높다

####단점
- 변화에 매우 취약
- 낮은 재사용성
- 낮은 확장성
	- DB 확장 비용은 상대적으로 비쌈, 로직을 DB에서 처리한다는 것은 비싼 자원을 사용한다는 것
- 테스드가 힘듬

###거대한 서비스 계층 방식
DB중심의 로직 구현과 유사하나 비즈니스 로직을 **서비스 계층**에 둔 다는 것이 차이    

DAO계층과 SQL은 단순해지고 DAO에서 리턴하는 결과물도 단순한 형태이기 때문에 DAO 계층의 재사용성은 높을 수 있음

서비스 계층의 코드는 여전히 업무 종속적이기 때문에 서비스 계층 수준에서는 여전히 중복도 많고 재사용성도 떨어짐    

####장점
- 객체지향적으로 로직을 구현
	- 그러나 아키텍처를 따라야 하기 때문에 제한적
- 테스트하기 수월

##오브젝트 중심 아키텍처
**도메인 모델**을 반영하는 오브젝트 구조를 만들어두고 그것을 각 계층 사이에서 정보를 전송하는 데 사용    
특정 계층에 종속되지 않으면서 애플리케이션 전방에서 사용

오브젝트를 **정보**를 담는 목적으로만 사용할 지 관련 **비즈니스 로직**까지 담을 지에 따라 다시 구분

###데이터와 오브젝트
데이터 중심의 아키텍처처는 DAO가 만드는 SQL의 결과가 데이터가 되며, 모든 계층의 코드가 의존하게 됨    

오브젝트는 SQL과 독립적, 다만 DB에서 가져온 데이터를 오브젝트 구조에 맞게 변환하는 작업이 필요    

###도메인 오브젝트 사용의 문제점
DAO가 비즈니스 로직을 모르기 때문에 도메인 오브젝트의 모든 필드 값을 채우는 경우가 대부분    
최적화된 SQL은 필요없는 필드를 불러오지 않기 때문에 성능 차이가 있을 수 있음    

####해결방법
- 지연된 로딩을 사용하여 최소한의 오브젝트 정보만 읽어오고 필요한 오브젝트는 필요 시점에 동적으로 읽어 오기
- 오브젝트를 필드의 사용정도에 따라 더 작은 오브젝트로 나누기
	- DAO와 서비스 계층간 결합도가 높아짐
- ORM 사용
	- BEST WAY!!
	- 기본적으로 지연된 로딩 기법 제공
	- 복잡한 DAO 코드 자동 생성
	- 오브젝트 캐시 사용 가능: 자주 사용하는 오브젝트를 메모리에 캐싱

###빈약한 도메인 오브젝트 방식
도메인 오브젝트를 **정보**를 담는 용도로만 사용    

서비스 계층이 핵심 비즈니스 로직을 갖게 되는 **거대 서비스 계층 방식**의 하나    

서비스 계층의 메소드에 대부분의 비즈니스 로직이 들어 있기 때문에 로직의 재사용성이 떨어지고 중복의 문제가 발생하기 쉬움
>사용자와 가까운 계층일 수록 메서드가 특정 업무 종속적일 수 있기 때문

###풍성한 도메인 오브젝트(영리한 도메인 오브젝트) 방식
도메인 오브젝트가 자신과 관련된 비즈니스 로직을 가짐    
서비스 계층에서는 도메인 오브젝트의 로직을 재사용    

데이터와 그 데이터를 사용하는 기능이 한 곳에 모인 응집도가 높은 구조

여러 도메인 오브젝트의 기능을 필요로하는 비즈니스 로직은 여전히 서비스 계층에 존재    
DAO 계층, 기반 서비스 계층 등에 접근이 필요한 비즈니스 로직 또한 서비스 계층에 존재    

도메인 오브젝트의 구조나 기능이 변하게 되면 전체 시스템에 영향을 주기 때문에 충실한 도메인 모델링과 도메인 오브젝트 개발이 선행되야

###도메인 계층 방식
도메인 오브젝트들이 하나의 **독립적인 계층**이 돼 서비스 계층과 데이터 액세스 계층 사이에 존재하게 하는 방식    
>서비스 계층에서 DAO 계층으로의 직접 접근이 불가한 것은 아니다. 특정 도메인 로직에 포함되지 않는 데이타 처리(i.e. 리포트 쿼리) 등을 위해서 접근 가능

도메인 오브젝트가 하나의 계층으로 설계되기 때문에 도메인 오브젝트가 직접 DAO 계층, 기반 서비스 계층 등에 직접 접근 가능    
더 많은 비즈니스 로직이 서비스 계층에서 도메인 오브젝트로 이전    

도메인 오브젝트는 스프링이 관리하는 빈이 아니기 때문에 AspectJ AOP를 사용하여 DAO 등 필요한 빈을 DI해야    

####문제점
프레젠테이션 계층이나 뷰 등에서 도메인 오브젝트 접근 가능하기 때문에 심각한 문제(백엔드에 작업 반영 등)발생할 수 있음    

####해결책
- AspectJ의 정책/표준 강제화
	- 포인트컷 표현식으로 특정 계층의 오브젝트가 사용할 수 있는 메소드의 범위를 제한
- DTO(Data Transfer Object) 사용
	- 별도의 정보 전달용 오브젝트에 도메인 오브젝트의 내용을 복사해 이용

##스프링 애플리케이션을 위한 아키텍처 설계
###계층형 아키텍처
스프링이 3계층 구조에 적합하도록 설계된 것은 사실이나, 3계층은 논리적이고 개념적인 구분일 뿐 3계층은 얼마든지 통합돼고 세분화 될 수 있음    

만약 계층을 합치게 된다면 프레젠테이션 계층과 서비스 계층을 합치는 것보다 서비스 계층과 데이터 액세스 계층을 합치는 것 권장    
>스프링 AOP를 이용해 트랜잭션 경계 설정하기가 애매하기 때문     
>프레젠테이션 계층의 오브젝트는 트랜잭션 단위로 삼기에 너무 크고 트랜잭션 전파를 통해 조합하기가 애매

MVC는 프레젠테이션 계층을 세분화

###정보 전송 아키텍처
프레젠테이션 계층의 MV 아키텍처에서도 모델은 도메인 오브젝트를 그대로 사용

###상태 관리와 빈 스코프
서버 기반의 엔터프라이즈 애플리케이션은 동시에 수많은 사용자의 요청을 처리해야 하기 때문에 **무상태**가 기본    
그러나 상태 관리가 필요한 경우가 있기 때문에, 상태를 어떻게 관리할지 결정해야    

파일 시스템, DB, HTTP 세션 등의 방법 외에도 빈의 **스코프**를 활용하여 상태유지 스타일의 어플리케이션을 만들 수도    

###외부 라이브러리 사용
- 팩토리 빈을 도입(스프링의 팩토리 빈 인터페이스를 구현)해 DI로 사용해야
- 특정 기술에 종속될지 않도록 서비스 추상화 필요
	- 추상 서비스 인터페이스를 구현해 기술과 연동하게 해주는 **어댑터 클래스** 이용
